// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "ClusterJudge.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <boost/make_shared.hpp>
#include <iostream>
#include <sstream>
#include <fstream>
#include <fcntl.h>
#include <sys/stat.h>
#include <stdarg.h>
#include <my_global.h>
#include <my_sys.h>
#include <mysql.h>
#include <hiredis.h>

// #define THRIFT_DEBUG

typedef struct stat Stat;

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;
using namespace  ::grouping_shared;
   
/********************************************************\
 *  utility
\********************************************************/
void split(const std::string &s, char delim, std::vector<std::string> &elems) {
   std::stringstream ss(s);
   std::string item;
   while (getline(ss, item, delim)) {
       elems.push_back(item);
   }
}

enum {
    T_LAW_DECR_1 = 1,
    T_LAW_DECR_2 = 3,
    T_ACTUAL_DECR = 5,
    T_LAW_INCR = 6,
    T_ACTUAL_INCR = 7
};

#define PREDICTABLE_MIN_GROUP_SIZE 15

typedef unsigned long long uint64;

struct CompactAlign {
   unsigned int index; // 0 or 1
   uint64 segment_pos; // segment position in uint64
   uint64 mask;  // mask introduces segment length
};

static std::map<int, std::vector<int> > code_lookup_table = {
   {T_LAW_DECR_1,   {1, 2, 4, 5}},
   {T_LAW_DECR_2,   {2, 3, 4, 6, 7, 8}},
   {T_ACTUAL_DECR,  {0, 2, 3, 6, 7, 8, 9, 10, 11, 12, 13, 15, 17, 19, 21, 65, 66, 81}},
   {T_LAW_INCR,     {1, 2, 72, 84, 88, 92}},
   {T_ACTUAL_INCR,  {1, 2, 3, 4, 6, 8, 9, 10, 15, 33, 34, 35, 49}}
};

static std::map<int, struct CompactAlign> align_table = {
   {T_LAW_DECR_1,   {0, 0,   0x000000000000ffffull}},
   {T_LAW_DECR_2,   {0, 16,  0x00000000ffff0000ull}},
   {T_ACTUAL_INCR,  {0, 32,  0xffffffff00000000ull}},
   {T_LAW_INCR,     {1, 0,   0x000000000000ffffull}},
   {T_ACTUAL_DECR,  {1, 16,  0xffffffffffff0000ull}}
};

static std::map<int, std::map<int, std::string> > code_to_scenario_map = {
   {T_LAW_DECR_1, { {1,     "未成年"},
                    {2,     "防卫过当"},
                    {3,     "中止犯罪"},
                    {4,     "从犯"}
                  }
   },
   {T_LAW_DECR_2, { {2,     "又聋又哑"},
                    {3,     "预备犯"},
                    {4,     "未遂"},
                    {6,     "自首"},
                    {8,     "重大立功"}
                   }
   },
   {T_ACTUAL_DECR, { {0,     "作用较小"}, 
                     {2,     "坦白"},
                     {3,     "认罪态度好"},
                     {6,     "初犯"},
                     {7,     "偶犯"},
                     {8,     "照顾人犯"},
                     {9,     "被害人过错"},
                     {10,    "取得谅解"},
                     {11,    "主动退赃"},
                     {12,    "赃物追缴"},
                     {13,    "补救损失"},
                     {15,    "达成和解"},
                     {17,    "投案"},
                     {19,    "协助公安"},
                     {21,    "情节较轻"},
                     {65,    "毒品有未流入社会"},
                     {66,    "吸食情节"},
                     {81,    "补缴税款"}
                    }
   },  
   {T_LAW_INCR, {{1, "累犯"},
                 {2, "毒品再犯"},
                 {72, "有殴打情节"},
                 {84, "猥亵儿童"},
                 {88, "冒充人民警察招摇撞骗"},
                 {92, "索取贿赂"}
                }
   },
   {T_ACTUAL_INCR, {{1, "劣迹"},
                    {2, "前科"},
                    {3, "惯犯"},
                    {4, "认罪态度差"},
                    {6, "手段动机"},
                    {8, "拒绝退赃"},
                    {9, "拒绝赔偿"},
                    {10, "犯罪后逃跑"},
                    {15, "作用较大"},
                    {33, "无证驾驶"},
                    {34, "酒驾"},
                    {35, "驾驶无牌车"},
                    {49, "入户盗窃"}
                   }
   }
};     

static std::string  g_log_file;
pthread_mutex_t     g_mutex_log;
static std::string  g_doc_path_prefix = "/root/extra/segment/";

static int do_mkdir(const char *path, mode_t mode)
{
    Stat            st;
    int             status = 0;

    if (stat(path, &st) != 0)
    {
        /* Directory does not exist. EEXIST for race condition */
        if (mkdir(path, mode) != 0 && errno != EEXIST)
            status = -1;
    }
    else if (!S_ISDIR(st.st_mode))
    {
        status = -1;
    }

    return(status);
}

void decode_scenarios(uint64& first,
                      uint64& second,
                      std::vector<std::string>& scenarios)
{
   uint64 data[2] = {0ull};
   data[0] = first;
   data[1] = second;

   for (auto& align: align_table) {
      uint64 encode = (data[align.second.index] & align.second.mask) >> align.second.segment_pos;
      for(int i = 0; encode; ++i) {
         if (encode & 0x1) {
            int code = code_lookup_table[align.first][i];
            scenarios.push_back(code_to_scenario_map[align.first][code]);
         }

         encode >>= 1;
      }
   }
}

void set_log_file_name(void) {
   time_t rawtime;
   struct tm * timeinfo;
   char buffer [100] = {'\0'};

   time (&rawtime);
   timeinfo = localtime (&rawtime);

   strftime (buffer,100,"logs/%Y-%m-%d_%H%M%S.thrift.log",timeinfo);
   g_log_file = buffer;

   do_mkdir("logs", 0777);
}

void XXX_write_log_file(const char* str, ...) {
   pthread_mutex_lock(&g_mutex_log);
   FILE* f = fopen(g_log_file.c_str(), "a");
   if (f) {
      va_list arglist;
      va_start(arglist, str);
      vfprintf(f, str, arglist);
      va_end(arglist);

      fclose(f);
   }
   pthread_mutex_unlock(&g_mutex_log);
}

typedef std::pair<uint64, uint64> uint64_pair;

class Punishment {
public:
   Punishment(int docid, unsigned int punishment, unsigned int code) 
      : m_docid(docid)
   {
      m_lst_punishment_code.push_back(std::make_pair(punishment, code));
   }

   void add_punishment(unsigned int punishment, unsigned int code) {
      m_lst_punishment_code.push_back(std::make_pair(punishment, code));
   }

   int get_docid() {
      return m_docid;
   }

   std::list<std::pair<unsigned int, unsigned int> >& get_punishment_code() {
      return m_lst_punishment_code;
   }

private: 
   int  m_docid;
   std::list<std::pair<unsigned int, unsigned int> > m_lst_punishment_code;
};

class CompactPunishment {
public:
   CompactPunishment(int docid, uint64 data_1, uint64 data_2)
      : m_docid(docid)
   {
      m_data.first = data_1;
      m_data.second = data_2;
   }

   int get_docid() {
      return m_docid;
   }

   uint64& get_data1() {
      return m_data.first;
   }

   uint64& get_data2() {
      return m_data.second;
   }

   uint64_pair* get_decoded_senarios() {
      return &m_data;
   }

private:
   int     m_docid;
   std::pair<uint64, uint64> m_data;
};

inline bool compare_scenarios_group_by_docids(
    const std::pair<const uint64_pair*, std::list<int>*>& one,
    const std::pair<const uint64_pair*, std::list<int>*>& other)
{
    return one.second->size() > other.second->size();
}

inline bool compare_scenarios_group_by_size(
    const std::pair<const uint64_pair*, unsigned int>& one,
    const std::pair<const uint64_pair*, unsigned int>& other)
{
    return one.second > other.second;
}

bool renew_live_time(redisContext* context, 
                     const std::string crime, 
                     const std::vector<std::pair<uint64_pair*, unsigned int> >& scenario_groups) 
{
    if (scenario_groups.size() <= 0) 
        return true;

    bool ret = true;
    std::string command;
    std::list<std::string> command_list;
    
    command_list.push_back("MULTI");  // start transaction
    command = "expire crime:" + crime + " 3600";   // 1个小时
    command_list.push_back(command);

    for(auto& elem: scenario_groups) {
       command = "expire crime:" + crime + ":" + std::to_string(elem.first->first) + ":" + 
                 std::to_string(elem.first->second) + " 3600";
       command_list.push_back(command);  
    }
    command_list.push_back("EXEC");

    for (auto& command : command_list) {
       redisReply* reply = static_cast<redisReply*>(redisCommand(context, command.c_str())); 
       if (reply->type == REDIS_REPLY_ERROR) {
          ret = false;
          break;
       }
    }

    return ret;
}

bool write_to_redis_cache(redisContext* context, 
                          const std::string& crime, 
                          const std::vector<std::pair<const uint64_pair*, std::list<int>*> >& senario_groups) 
{
   if (senario_groups.size() <= 0) 
      return true;

   bool ret = true;
   std::string command;
   std::list<std::string> command_list;
   command_list.push_back("MULTI");   // begin transaction
   command = "HMSET crime:" + crime;
   for(size_t i = 0; i < senario_groups.size(); ++i) {
      command += " crime:" + crime + ":" + std::to_string(senario_groups[i].first->first) + ":" + 
                 std::to_string(senario_groups[i].first->second);
      command += " " + std::to_string(senario_groups[i].second->size());

      if ((i+1) % 10 == 0) {
         command_list.push_back(command);
         command = "HMSET crime:" + crime;
      }
   }

   if (senario_groups.size() % 10 != 0) {
      command_list.push_back(command);
   }
   command = "expire crime:" + crime + " 3600";   // set expire time of hash "crime:盗窃罪"
   command_list.push_back(command);

   for(size_t i = 0; i < senario_groups.size(); ++i) {
      command = "RPUSH crime:" + crime + ":" + std::to_string(senario_groups[i].first->first) + ":" + 
                 std::to_string(senario_groups[i].first->second);
      const std::list<int>&  docid_list = *senario_groups[i].second;

      size_t j = 0;
      for(auto& docid : docid_list) {
         command += " " + std::to_string(docid);  
         ++j;
         if (j % 10 == 0) {
            command_list.push_back(command);
            command = "RPUSH crime:" + crime + ":" + std::to_string(senario_groups[i].first->first) + ":" + 
                       std::to_string(senario_groups[i].first->second);
         }
      }
      if (docid_list.size() % 10 != 0) {
         command_list.push_back(command);
      }
      // set expire time of list "crime:盗窃罪:524288:75497472"
      command = "expire crime:" + crime + ":"  + std::to_string(senario_groups[i].first->first) + ":" + 
                std::to_string(senario_groups[i].first->second) + " 3600";   
      command_list.push_back(command);
   }
   command_list.push_back("EXEC");   // end transaction
   
   for (auto& command : command_list) {
      redisReply* reply = static_cast<redisReply*>(redisCommand(context, command.c_str())); 
      if (reply->type == REDIS_REPLY_ERROR) {
         std::cout << reply->str << std::endl;
         ret = false;
         break;
      }
   }

//   std::cout << "grouping transactions:\n";
//   for (auto& command: command_list) {
//      std::cout << command << std::endl;
//   }
//   std::cout << std::endl;

   return ret;
}

struct senario_ptr_gt {
   bool operator()(const uint64_pair* lhs, const uint64_pair* rhs) {
      return *lhs > *rhs;
   }
};

typedef std::map<uint64_pair*, std::list<int>*, senario_ptr_gt> SenarioGroupMap;

class ScenariosGroupImpl {
public:
   ScenariosGroupImpl(MYSQL* conn, redisContext* redis_context) 
     : m_conn(conn), m_redis_context(redis_context)
   {}

   ScenariosGroupImpl() : m_conn(NULL), m_redis_context(NULL) {
   }

   ~ScenariosGroupImpl() {
       std::cout << "ScenariosGroupImpl::~ScenariosGroupImpl()" << std::endl; 
   }

   void set_connection(MYSQL* conn) {
      m_conn = conn;
   }

   void set_redis_context(redisContext* context) {
      m_redis_context = context;
   }

   int get_docid_list(std::list<int>& docid_list,
                      const std::string& crime,
                      const std::string& data1,
                      const std::string& data2,
                      std::string& prompt)
   {
       int ret = -1;
       char stmt[1024] = {'\0'};
      
       redisReply *reply = NULL;
       redisReply** tmp;
       int docid;
       
       std::string key = "crime:" + crime + ":" + data1 + ":" + data2;
       if (!m_redis_context) {
          XXX_write_log_file("[error] cache server is not currently available for query %s.\n", key.c_str());
          prompt = "redis 服务器当前不可用";
          ret = -105;
          goto Exit_Func;
       }

#ifdef THRIFT_DEBUG
       std::cout << "lrange " << key << " 0 -1" << std::endl;
#endif       
       reply = static_cast<redisReply*>(redisCommand(m_redis_context, ("lrange " + key + " 0 -1").c_str()));
       if (reply->type == REDIS_REPLY_ERROR) {
          XXX_write_log_file("[error] redis fail to execute 'lrange %s 0 -1' command: %s\n", key.c_str(), reply->str);
          prompt = "执行redis查询组内文档列表失败";
          ret = -106;
          goto Exit_Func;
       }
       
       if (reply->type != REDIS_REPLY_NIL) {
          if (reply->type != REDIS_REPLY_ARRAY) {
             XXX_write_log_file("[error] cache server go wrong for query %s.\n", key.c_str());
             prompt = "redis服务器返回组内文档出错";
             ret = -107;
             goto Exit_Func;
          }
          
         
          if (reply->elements) {
             for (int i = 0; i < reply->elements; ++i) {
                docid = strtol(reply->element[i]->str, NULL, 10);
                docid_list.push_back(static_cast<int>(docid));
             }
             ret = 1;
          }
          else {
             XXX_write_log_file("[error] 数据已经过期.\n", key.c_str());
             prompt = "redis cache数据已经过期";
             ret = -108;      
          }
       }
       else {
          prompt = "redis服务器未知行为";
          ret = 0;
       }
Exit_Func:
#ifdef THRIFT_DEBUG
       std::cout << "array of cid of key '" << key << "' is: "  << std::endl;
       for (auto& x : docid_list) {
         std::cout << x << " ";
       }
#endif       
       return ret;
   }

   int group_scenarios(std::vector<std::pair<uint64_pair*, unsigned int> >& scenarios_groups,
                       const std::string& crime, 
                       std::string& prompt)
   {
       int ret = -1;
       char stmt[1024] = {'\0'};
       
       MYSQL_RES* res_set;
       MYSQL_ROW  prev_row = NULL;
       MYSQL_ROW  row;
       uint64     cid;
       unsigned long docid = 0;
       unsigned long punishment = 0;
       unsigned long code = 0;
       const char* name = NULL;
            
       unsigned long   prev_docid = 0;
    
       // encode
       uint64 data[2] = {0};
       int pos = 0;
       uint64 bit_val = 0;
       
       std::list<Punishment*> lst_punishment_scenarios;
       std::list<CompactPunishment*> lst_compact_punishment_scenarios;
    
       SenarioGroupMap  map_scenarios_group;
       std::vector<std::pair<const uint64_pair*, std::list<int>*> > scenarios_group_array;

       std::string key;
       redisReply *reply = NULL;
       redisReply** tmp;
       std::vector<std::string> string_array;
       unsigned int sgroup_size;
    
       if (!m_redis_context) {
          XXX_write_log_file("[error] cache server is not currently available for query %s.\n", crime.c_str());
          prompt = "redis 服务器当前不可用";
          ret = -105;
          goto Exit_Func;
       }

       key = "crime:" + crime;
       reply = static_cast<redisReply*>(redisCommand(m_redis_context, ("hgetall " + key).c_str()));

       if (reply->type == REDIS_REPLY_ERROR) {
          XXX_write_log_file("[error] redis fail to execute 'hgetall %s' command: %s\n", key.c_str(), reply->str);
          prompt = "执行redis查询获取分组信息失败";
          ret = -106;
          goto Exit_Func;
       }

       if (reply->type != REDIS_REPLY_NIL) {
          if (reply->type != REDIS_REPLY_ARRAY) {
             XXX_write_log_file("[error] cache server go wrong for query %s.\n", crime.c_str());
             prompt = "redis服务器返回分组信息出错";
             ret = -107;
             goto Exit_Func;
          }
          
         
          if (reply->elements) {
             for(tmp = reply->element; *tmp; tmp += 2) {
                split((*tmp)->str, ':', string_array);
                assert(string_array.size() == 4);
                data[0] = strtoull(string_array[2].c_str(), NULL, 10);
                data[1] = strtoull(string_array[3].c_str(), NULL, 10);
                sgroup_size = strtoul((*(tmp+1))->str, NULL, 10);
                uint64_pair* pr = new uint64_pair(data[0], data[1]);
                scenarios_groups.push_back(std::make_pair(pr, sgroup_size));

                string_array.clear();
             }
             std::sort(scenarios_groups.begin(), scenarios_groups.end(), compare_scenarios_group_by_size);

             std::cout << "retrieve data from redis cache\n";
             if (!renew_live_time(m_redis_context, crime, scenarios_groups)) {
                XXX_write_log_file("[error] fail to execute expire transaction for %s senario groups.\n", crime.c_str());
                printf("[error] fail to execute expire transaction for %s senario groups.\n", crime.c_str());
             }
             else {
                std::cout << "renew expired time\n";
             }
          }
       }
       
       if (scenarios_groups.size() <= 0) {

          /*
           *  corner case: 多个被告，以及从轻从重情节
           *               判决信息只提取了一个被告
           */
          sprintf(stmt, "select o.id, o.doc_id, o.accused, o.punishment, o.code from "
                        "doc_punishment_code o inner join (select doc_id, crime from doc_sentence"
                        " group by doc_id having count(*) = 1 and crime = '%s') "
                        "as a using(doc_id)",
                        crime.c_str());
               
          // fetch punishment scenarios of the same crime which corresponding with one or several accused
          if (!m_conn || mysql_query(m_conn, stmt) != 0) {
             XXX_write_log_file("[error] fail to execute sql query for %s.\n", crime.c_str());

             if (!m_conn) {
                prompt = "数据查询链接没有建立成功";
                ret = -103;
             } 
             else {
                prompt = "执行数据查询失败";
                ret = -104;
             }
             goto Exit_Func;
          }
          
          res_set = mysql_store_result(m_conn);
          if (res_set) {
             Punishment* person_scenarios;
             while((row = mysql_fetch_row(res_set)) != NULL) {
                cid = strtoull(row[0], NULL, 0);     // id of doc_punishment_code table, use cid can trace its related doc_id
                docid = strtoul(row[1], NULL, 10);
                name = row[2];
                punishment = strtoul(row[3], NULL, 10);
                code = strtoul(row[4], NULL, 10);

                if (prev_row && docid == prev_docid && strcmp(row[2], prev_row[2]) == 0) {
                   person_scenarios->add_punishment(punishment, code);
                }
                else {
                   person_scenarios = new Punishment(static_cast<int>(docid), 
                                                     static_cast<unsigned int>(punishment), 
                                                     static_cast<unsigned int>(code));
                   lst_punishment_scenarios.push_back(person_scenarios);
                }

                prev_row = row;
                prev_docid = docid;
             }

             mysql_free_result(res_set);
          }
          else { 
             XXX_write_log_file("[info] there is no punishment result for %s.\n", crime.c_str());
             ret = 0;
             goto Exit_Func;
          }

          for (auto& item : lst_punishment_scenarios) {
             data[1] = data[0] = 0ull;
             for (auto& scenario: item->get_punishment_code()) {
                // std::cout << item->get_cid() << "|" << scenario.first << "|" << scenario.second << std::endl;
                std::vector<int> &v = code_lookup_table[scenario.first];
                struct CompactAlign& align = align_table[scenario.first];
                pos = align.segment_pos;
                // !!! find can be replaced by lower_bound() for efficiency
                pos += std::distance(v.begin(), std::find(v.begin(), v.end(), scenario.second));
                assert(pos <= 63);
                bit_val = 1ull << pos;
                data[align.index] |= bit_val;
             }
             lst_compact_punishment_scenarios.push_back(new CompactPunishment(item->get_docid(), data[0], data[1]));
          }

          // free memory
          for (auto& item : lst_punishment_scenarios) {
             delete item;
          }
          lst_punishment_scenarios.clear();
          
          for (auto& item : lst_compact_punishment_scenarios) {
             uint64_pair* pr = item->get_decoded_senarios();
             SenarioGroupMap::iterator it =
                  map_scenarios_group.find(pr);

             std::list<int>* docid_list = NULL;
             if (it == map_scenarios_group.end()) {
                docid_list = new std::list<int>();
                map_scenarios_group[pr] = docid_list;
             }
             else {
                docid_list = it->second;
             }
             docid_list->push_back(item->get_docid());
             // map_scenarios_group[std::make_pair(item->get_data1(), item->get_data2())].push_back(item->get_cid()); 
          }

          for (auto& item: map_scenarios_group) {
             if (item.second->size() > PREDICTABLE_MIN_GROUP_SIZE) {
                scenarios_group_array.push_back(std::make_pair(item.first, item.second)); 
             }
          }

          std::sort(scenarios_group_array.begin(), scenarios_group_array.end(), compare_scenarios_group_by_docids);

          if (scenarios_group_array.size() > 0)
             std::cout << "retrieve data by calculation\n";
          
          if (!write_to_redis_cache(m_redis_context, crime, scenarios_group_array)) {
             XXX_write_log_file("[error] fail to execute transaction for storing senario groups of %s.\n", crime.c_str());
             printf("[error] fail to execute transaction for storing senario groups of %s.\n", crime.c_str());
          }
          else {
             std::cout << "write data to redis cache\n";
          }
          
          // construct list<judge groups>       
          for (auto& item: scenarios_group_array) {
             uint64_pair* pr = new uint64_pair(item.first->first, item.first->second);
             // !! <data1, data2> is originated from lst_compact_punishment_scenarios
             scenarios_groups.push_back(std::make_pair(pr, item.second->size()));  
          }

          for (auto& item: lst_compact_punishment_scenarios) {
             delete item;
          }

          // free list<int> i.e. id list space
          // note: scenarios_groups only contains parts of map_scenarios_group without counting in groups less than 15 items
          for (auto & item : map_scenarios_group) {
             delete item.second;  // map key <data1, data2> originated from: lst_compact_punishment_scenarios
          }
       }
      
       if (scenarios_groups.size() <= 0)  {
          prompt = "没有相应的分组信息";
          ret = 0;
       }
       else 
          ret = 1;

Exit_Func:
       freeReplyObject(reply);
       return ret;
   }

private:
   MYSQL*           m_conn;
   redisContext*    m_redis_context;
   
   // ! following fields should be deleted, since they are store in redis cache
};

class ClusterJudgeHandler : virtual public ClusterJudgeIf {
public:
   ClusterJudgeHandler() : m_conn(NULL), m_redis_context(NULL) {
      m_conn = mysql_init(NULL);  // mysql_thread_init() is auto called by mysql_init()
      if (m_conn) {
         my_bool reconnect = 1;
         mysql_options(m_conn, MYSQL_SET_CHARSET_NAME, "utf8");
         mysql_options(m_conn, MYSQL_OPT_RECONNECT, &reconnect);
         
         if (mysql_real_connect(m_conn, "127.0.0.1", "mysql", "axfdyhhi",
                                 "judgement", 0, NULL, 0) == NULL)
         {
            mysql_close(m_conn);
            m_conn = NULL;
         }
      }

      m_scenarios_group.set_connection(m_conn);

      struct timeval timeout = { 1, 500000 };
      m_redis_context = redisConnectWithTimeout("127.0.0.1", 6379, timeout);
      if (!m_redis_context || m_redis_context->err) {
         if (m_redis_context) {
            std::cout << "fail to allocate redis context" << std::endl;
         }
         else {
            std::cout << "Connection error: " << m_redis_context->errstr << std::endl; 
         }
         m_redis_context = NULL;
      }
      else {
         m_scenarios_group.set_redis_context(m_redis_context);
      }
      
   }

   ~ClusterJudgeHandler() {
      mysql_close(m_conn);  // not sure whether it is in need?
      mysql_thread_end();
      redisFree(m_redis_context);
   }
  
   void group_judge(std::vector<JudgeGroup> & _return, const std::string& crime) {
     // Your implementation goes here
     printf("group_judge\n");
   }

   void group_scenarios(rpc_call_group_scenarios_struct& _return, const std::string& crime, 
                        const int32_t page_no, const int32_t page_size)
   {
       std::string prompt;
       std::vector<std::pair<uint64_pair*, unsigned int> > scenarios_groups;
       int ret = m_scenarios_group.group_scenarios(scenarios_groups, crime, prompt);
       if (ret > 0) {
           assert(page_size > 0 && page_no > 0);

           int total_page = ceil(scenarios_groups.size() / static_cast<float>(page_size));
           std::cout << "total " << scenarios_groups.size() << " groups and total " << total_page << " pages" << std::endl;
           if (page_no > total_page || page_no < 1) {
              char info[1000] = {'\0'};
              sprintf(info, "请求页面超出范围，总共%d页，请求第%d页", total_page, page_no);
              QueryFailure qf;
              qf.__set_code(201);
              qf.__set_desc(info);

              for(auto& elem : scenarios_groups) {
                 delete elem.first;
              }

              throw qf;
           }
           else {
              int start = (page_no - 1) * page_size;
              int end = min(scenarios_groups.size(), page_no * page_size);
              assert(end > start);
              for (decltype(scenarios_groups.size()) i = start; i < end; ++i) {
                 ScenariosGroup group;
                 std::vector<std::string> scenarios;
                 decode_scenarios(scenarios_groups[i].first->first,
                                  scenarios_groups[i].first->second, 
                                  group.scenarios);
                 // group.__set_scenarios(scenarios);
                 group.__set_doc_count(scenarios_groups[i].second);
                 group.__set_data1(std::to_string(scenarios_groups[i].first->first));
                 group.__set_data2(std::to_string(scenarios_groups[i].first->second));
                 _return.page_data.push_back(group);
              }
              _return.total_pages = total_page;
             
              // free
              for(auto& elem : scenarios_groups) {
                 delete elem.first;
              }

           }
       } 
       else {
           QueryFailure qf;
           qf.__set_code(ret);
           qf.__set_desc(prompt);

           throw qf;
       }
   }

   void get_docs_of_sgroup(rpc_call_doc_group_struct& _return, 
                           const std::string& crime, 
                           const std::string& data1, const std::string& data2, 
                           const int32_t page_no, const int32_t page_size) 
   {
      std::list<int> docid_lst;
      std::string prompt;
      //std::cout << "asdf:" << crime << ":" << data1 << ":" << data2 << ":"
      //          << page_no << ":" << page_size << std::endl;
      int ret =  m_scenarios_group.get_docid_list(docid_lst, crime, data1, data2, prompt);
      if (ret > 0) {
         int total_page = ceil(docid_lst.size() / static_cast<float>(page_size));
         if (page_no > total_page || page_no < 1) {
              char info[1000] = {'\0'};
              sprintf(info, "请求页面超出范围，总共%d页，请求第%d页", total_page, page_no);
              QueryFailure qf;
              qf.__set_code(201);
              qf.__set_desc(info);
              throw qf;
         }

         int start = (page_no - 1) * page_size;
         int end = min(docid_lst.size(), page_no * page_size);
         assert(end > start);
         std::list<int>::iterator start_it = docid_lst.begin();
         std::advance(start_it, start);
         std::vector<int> docids_within_page;
         for(decltype(docid_lst.size()) i = start; i < end; ++i, ++start_it) {
            docids_within_page.push_back(*start_it);
         }

         std::string doc_ids_str = std::to_string(docids_within_page[0]);
         for (size_t i = 1; i < docids_within_page.size(); ++i) {
            doc_ids_str += ", " + std::to_string(docids_within_page[i]);
         }

         std::string stmt = "select b.doc_id, b.name, b.is_org, b.penalty, b.duration, b.probation, b.fine, b.court, b.docname, b.recorddate,"
                            "  CONCAT('" + g_doc_path_prefix + "', REPLACE(CONCAT_WS('/', court.href, b.type, b.href),"
                            " '.htm', '.txt')) from (select * from "
                            "(select doc_id, name, is_org, penalty, max(duration) as duration, probation, fine from"
                            " doc_sentence where doc_id IN (" + doc_ids_str + ")  group by doc_id) as a "
                            "inner join doc_url_xs_20150520 on a.doc_id = doc_url_xs_20150520.id) as b inner join "
                            "court on b.court_id = court.id";

         MYSQL_RES* res_set;
         MYSQL_ROW  row;
         int            docid;
         std::string    name;
         unsigned long  penalty;
         unsigned long  duration;
         unsigned long  probation = 0;
         double         fine = 0.0;
        
#ifdef THRIFT_DEBUG        
         std::cout << "execute SQL statement: " << std::endl << stmt << std::endl;
#endif

         if (!m_conn || mysql_query(m_conn, stmt.c_str()) != 0) {
            XXX_write_log_file("[error] fail to execute sql query for retrieve page doc info of %s grouped senarios.\n", crime.c_str());

            if (!m_conn) {
               prompt = "数据查询链接没有建立成功";
               ret = -103;
            } 
            else {
               prompt = "执行数据查询失败";
               ret = -104;
            }
            
            QueryFailure qf;
            qf.__set_code(ret);
            qf.__set_desc(prompt);

            throw qf;
         }

         res_set = mysql_store_result(m_conn);
         if (res_set) {
            while((row = mysql_fetch_row(res_set)) != NULL) {
               Sentence s;
               std::vector<Sentence> sentence_lst;
               struct doc_info doc;
               
               docid = strtol(row[0], NULL, 10);
               s.__set_accused(row[1]);
               s.__set_penalty(static_cast<Penalty::type>(strtol(row[3], NULL, 10)));
               s.__set_duration(static_cast<int>(strtol(row[4], NULL, 10)));

               if (row[5]) {
                  s.__set_probation(strtod(row[5], NULL));
               }

               if (row[6]) {
                  s.__set_fine(strtod(row[6], NULL));
               }

               std::ifstream t(row[10]);
               std::stringstream buffer;
               buffer << t.rdbuf();

               sentence_lst.push_back(s);
               doc.__set_docid(docid);
               doc.__set_sentences(sentence_lst);
               doc.__set_injury(1 << 31);
               doc.__set_name(row[8] ? row[8]: "UNKN");
               doc.__set_date(row[9] ? row[9] : "0000-00-00");
               doc.__set_court_name(row[7] ? row[7]: "UNKN");
               doc.__set_kind(0);
               doc.__set_full_text(buffer.str());
               _return.page_data.push_back(doc);
            }
            mysql_free_result(res_set);
            _return.total_pages = total_page;
         }

         if ((page_no < page_size && _return.page_data.size() != page_size) || 
             _return.page_data.size() == 0)
         {
            QueryFailure qf;
            
            if (_return.page_data.size() == 0) {
               qf.__set_code(-109);
               qf.__set_desc("返回0条文书信息");
            }
            else {
               qf.__set_code(-110);
               qf.__set_desc("没有达到期望返回的" + std::to_string(page_size) + "条文书信息");
            }

            throw qf;
         }

      }
      else {
         QueryFailure qf;
         qf.__set_code(ret);
         qf.__set_desc(prompt);

         throw qf;
      }

      fflush(stdout);
   }

   void get_judge_bases(std::vector<JudgeBases> & _return, const std::vector<int32_t> & docid_array) {
      // Your implementation goes here
      printf("get_judge_bases\n");
   }

   void get_scenarios_group_sentences(std::vector<Sentence> & _return, 
                                      const std::string& crime, 
                                      const int32_t group_id, 
                                      const int32_t page_no, 
                                      const int32_t page_size)
   {
      // Your implementation goes here
      Sentence s1;
      s1.__set_accused("张三");
      s1.__set_penalty(Penalty::P_LIMIT);
      s1.__set_duration(18);
      s1.__set_probation(0);
      s1.__set_fine(0);
      _return.push_back(s1);
      _return.push_back(s1);
   }

private:
   MYSQL*           m_conn;
   redisContext*    m_redis_context;
   ScenariosGroupImpl  m_scenarios_group;
};

class ClusterJudgeCloneFactory : virtual public ClusterJudgeIfFactory 
{
public:
   virtual ~ClusterJudgeCloneFactory() {}
   virtual ClusterJudgeIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo)
   {
       boost::shared_ptr<TSocket> sock = boost::dynamic_pointer_cast<TSocket>(connInfo.transport);
       std::cout << "Incoming connection\n";
       std::cout << "\tSocketInfo: "  << sock->getSocketInfo() << "\n";
       std::cout << "\tPeerHost: "    << sock->getPeerHost() << "\n";
       std::cout << "\tPeerAddress: " << sock->getPeerAddress() << "\n";
       std::cout << "\tPeerPort: "    << sock->getPeerPort() << "\n";
       return new ClusterJudgeHandler;
   }
   virtual void releaseHandler( ClusterJudgeIf* handler) {
       delete handler;
   } 
};

int main(int argc, char **argv) {
   set_log_file_name();
   mysql_library_init(0, NULL, NULL);

   TThreadedServer server(
      boost::make_shared<ClusterJudgeProcessorFactory>(boost::make_shared<ClusterJudgeCloneFactory>()),
      boost::make_shared<TServerSocket>(9090), //port
      boost::make_shared<TBufferedTransportFactory>(),
      boost::make_shared<TBinaryProtocolFactory>());

   std::cout << "start server..." << std::endl;
   server.serve();

   mysql_library_end();
   return 0;
}

