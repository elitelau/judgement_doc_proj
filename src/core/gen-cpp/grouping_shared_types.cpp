/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "grouping_shared_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace grouping_shared {

int _kInjuryLevelValues[] = {
  InjuryLevel::SLIGHT,
  InjuryLevel::SERIOUS,
  InjuryLevel::DEATH,
  InjuryLevel::UNKN
};
const char* _kInjuryLevelNames[] = {
  "SLIGHT",
  "SERIOUS",
  "DEATH",
  "UNKN"
};
const std::map<int, const char*> _InjuryLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kInjuryLevelValues, _kInjuryLevelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kPenaltyValues[] = {
  Penalty::P_LIMIT,
  Penalty::P_DETENTION,
  Penalty::P_CTRL,
  Penalty::P_LIFE,
  Penalty::P_DEATH,
  Penalty::P_FREE
};
const char* _kPenaltyNames[] = {
  "P_LIMIT",
  "P_DETENTION",
  "P_CTRL",
  "P_LIFE",
  "P_DEATH",
  "P_FREE"
};
const std::map<int, const char*> _Penalty_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kPenaltyValues, _kPenaltyNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


PunishmentScenarios::~PunishmentScenarios() throw() {
}


void PunishmentScenarios::__set_first(const int64_t val) {
  this->first = val;
}

void PunishmentScenarios::__set_second(const int64_t val) {
  this->second = val;
}

uint32_t PunishmentScenarios::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_first = false;
  bool isset_second = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->first);
          isset_first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->second);
          isset_second = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_first)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_second)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PunishmentScenarios::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PunishmentScenarios");

  xfer += oprot->writeFieldBegin("first", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->first);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("second", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->second);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PunishmentScenarios &a, PunishmentScenarios &b) {
  using ::std::swap;
  swap(a.first, b.first);
  swap(a.second, b.second);
}

PunishmentScenarios::PunishmentScenarios(const PunishmentScenarios& other0) {
  first = other0.first;
  second = other0.second;
}
PunishmentScenarios& PunishmentScenarios::operator=(const PunishmentScenarios& other1) {
  first = other1.first;
  second = other1.second;
  return *this;
}
void PunishmentScenarios::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PunishmentScenarios(";
  out << "first=" << to_string(first);
  out << ", " << "second=" << to_string(second);
  out << ")";
}


Injury::~Injury() throw() {
}


void Injury::__set_level(const InjuryLevel::type val) {
  this->level = val;
}

void Injury::__set_degree(const int8_t val) {
  this->degree = val;
}

void Injury::__set_number(const int16_t val) {
  this->number = val;
}

uint32_t Injury::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_level = false;
  bool isset_degree = false;
  bool isset_number = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->level = (InjuryLevel::type)ecast2;
          isset_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->degree);
          isset_degree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->number);
          isset_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_level)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_degree)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_number)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Injury::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Injury");

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("degree", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->degree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->number);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Injury &a, Injury &b) {
  using ::std::swap;
  swap(a.level, b.level);
  swap(a.degree, b.degree);
  swap(a.number, b.number);
}

Injury::Injury(const Injury& other3) {
  level = other3.level;
  degree = other3.degree;
  number = other3.number;
}
Injury& Injury::operator=(const Injury& other4) {
  level = other4.level;
  degree = other4.degree;
  number = other4.number;
  return *this;
}
void Injury::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Injury(";
  out << "level=" << to_string(level);
  out << ", " << "degree=" << to_string(degree);
  out << ", " << "number=" << to_string(number);
  out << ")";
}


JudgeBases::~JudgeBases() throw() {
}


void JudgeBases::__set_scenarios(const PunishmentScenarios& val) {
  this->scenarios = val;
}

void JudgeBases::__set_amount(const double val) {
  this->amount = val;
__isset.amount = true;
}

void JudgeBases::__set_injury_scenarios(const std::vector<Injury> & val) {
  this->injury_scenarios = val;
__isset.injury_scenarios = true;
}

uint32_t JudgeBases::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_scenarios = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scenarios.read(iprot);
          isset_scenarios = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->amount);
          this->__isset.amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->injury_scenarios.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->injury_scenarios.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += this->injury_scenarios[_i9].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.injury_scenarios = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_scenarios)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t JudgeBases::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("JudgeBases");

  xfer += oprot->writeFieldBegin("scenarios", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->scenarios.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.amount) {
    xfer += oprot->writeFieldBegin("amount", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->amount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.injury_scenarios) {
    xfer += oprot->writeFieldBegin("injury_scenarios", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->injury_scenarios.size()));
      std::vector<Injury> ::const_iterator _iter10;
      for (_iter10 = this->injury_scenarios.begin(); _iter10 != this->injury_scenarios.end(); ++_iter10)
      {
        xfer += (*_iter10).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(JudgeBases &a, JudgeBases &b) {
  using ::std::swap;
  swap(a.scenarios, b.scenarios);
  swap(a.amount, b.amount);
  swap(a.injury_scenarios, b.injury_scenarios);
  swap(a.__isset, b.__isset);
}

JudgeBases::JudgeBases(const JudgeBases& other11) {
  scenarios = other11.scenarios;
  amount = other11.amount;
  injury_scenarios = other11.injury_scenarios;
  __isset = other11.__isset;
}
JudgeBases& JudgeBases::operator=(const JudgeBases& other12) {
  scenarios = other12.scenarios;
  amount = other12.amount;
  injury_scenarios = other12.injury_scenarios;
  __isset = other12.__isset;
  return *this;
}
void JudgeBases::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "JudgeBases(";
  out << "scenarios=" << to_string(scenarios);
  out << ", " << "amount="; (__isset.amount ? (out << to_string(amount)) : (out << "<null>"));
  out << ", " << "injury_scenarios="; (__isset.injury_scenarios ? (out << to_string(injury_scenarios)) : (out << "<null>"));
  out << ")";
}


JudgeGroup::~JudgeGroup() throw() {
}


void JudgeGroup::__set_bases(const JudgeBases& val) {
  this->bases = val;
}

void JudgeGroup::__set_doc_count(const int32_t val) {
  this->doc_count = val;
}

void JudgeGroup::__set_data1(const std::string& val) {
  this->data1 = val;
}

void JudgeGroup::__set_data2(const std::string& val) {
  this->data2 = val;
}

uint32_t JudgeGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_bases = false;
  bool isset_doc_count = false;
  bool isset_data1 = false;
  bool isset_data2 = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bases.read(iprot);
          isset_bases = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->doc_count);
          isset_doc_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data1);
          isset_data1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data2);
          isset_data2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_bases)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_doc_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data1)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data2)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t JudgeGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("JudgeGroup");

  xfer += oprot->writeFieldBegin("bases", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->bases.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("doc_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->doc_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data1", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->data1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data2", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->data2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(JudgeGroup &a, JudgeGroup &b) {
  using ::std::swap;
  swap(a.bases, b.bases);
  swap(a.doc_count, b.doc_count);
  swap(a.data1, b.data1);
  swap(a.data2, b.data2);
}

JudgeGroup::JudgeGroup(const JudgeGroup& other13) {
  bases = other13.bases;
  doc_count = other13.doc_count;
  data1 = other13.data1;
  data2 = other13.data2;
}
JudgeGroup& JudgeGroup::operator=(const JudgeGroup& other14) {
  bases = other14.bases;
  doc_count = other14.doc_count;
  data1 = other14.data1;
  data2 = other14.data2;
  return *this;
}
void JudgeGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "JudgeGroup(";
  out << "bases=" << to_string(bases);
  out << ", " << "doc_count=" << to_string(doc_count);
  out << ", " << "data1=" << to_string(data1);
  out << ", " << "data2=" << to_string(data2);
  out << ")";
}


ScenariosGroup::~ScenariosGroup() throw() {
}


void ScenariosGroup::__set_scenarios(const std::vector<std::string> & val) {
  this->scenarios = val;
}

void ScenariosGroup::__set_doc_count(const int32_t val) {
  this->doc_count = val;
}

void ScenariosGroup::__set_data1(const std::string& val) {
  this->data1 = val;
}

void ScenariosGroup::__set_data2(const std::string& val) {
  this->data2 = val;
}

uint32_t ScenariosGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_scenarios = false;
  bool isset_doc_count = false;
  bool isset_data1 = false;
  bool isset_data2 = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->scenarios.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _etype18;
            xfer += iprot->readListBegin(_etype18, _size15);
            this->scenarios.resize(_size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              xfer += iprot->readString(this->scenarios[_i19]);
            }
            xfer += iprot->readListEnd();
          }
          isset_scenarios = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->doc_count);
          isset_doc_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data1);
          isset_data1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data2);
          isset_data2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_scenarios)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_doc_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data1)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data2)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ScenariosGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScenariosGroup");

  xfer += oprot->writeFieldBegin("scenarios", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->scenarios.size()));
    std::vector<std::string> ::const_iterator _iter20;
    for (_iter20 = this->scenarios.begin(); _iter20 != this->scenarios.end(); ++_iter20)
    {
      xfer += oprot->writeString((*_iter20));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("doc_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->doc_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data1", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->data1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data2", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->data2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScenariosGroup &a, ScenariosGroup &b) {
  using ::std::swap;
  swap(a.scenarios, b.scenarios);
  swap(a.doc_count, b.doc_count);
  swap(a.data1, b.data1);
  swap(a.data2, b.data2);
}

ScenariosGroup::ScenariosGroup(const ScenariosGroup& other21) {
  scenarios = other21.scenarios;
  doc_count = other21.doc_count;
  data1 = other21.data1;
  data2 = other21.data2;
}
ScenariosGroup& ScenariosGroup::operator=(const ScenariosGroup& other22) {
  scenarios = other22.scenarios;
  doc_count = other22.doc_count;
  data1 = other22.data1;
  data2 = other22.data2;
  return *this;
}
void ScenariosGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScenariosGroup(";
  out << "scenarios=" << to_string(scenarios);
  out << ", " << "doc_count=" << to_string(doc_count);
  out << ", " << "data1=" << to_string(data1);
  out << ", " << "data2=" << to_string(data2);
  out << ")";
}


rpc_call_group_scenarios_struct::~rpc_call_group_scenarios_struct() throw() {
}


void rpc_call_group_scenarios_struct::__set_page_data(const std::vector<ScenariosGroup> & val) {
  this->page_data = val;
}

void rpc_call_group_scenarios_struct::__set_total_pages(const int32_t val) {
  this->total_pages = val;
}

uint32_t rpc_call_group_scenarios_struct::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_page_data = false;
  bool isset_total_pages = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->page_data.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->page_data.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += this->page_data[_i27].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_page_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total_pages);
          isset_total_pages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_page_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_total_pages)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t rpc_call_group_scenarios_struct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("rpc_call_group_scenarios_struct");

  xfer += oprot->writeFieldBegin("page_data", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->page_data.size()));
    std::vector<ScenariosGroup> ::const_iterator _iter28;
    for (_iter28 = this->page_data.begin(); _iter28 != this->page_data.end(); ++_iter28)
    {
      xfer += (*_iter28).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_pages", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->total_pages);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(rpc_call_group_scenarios_struct &a, rpc_call_group_scenarios_struct &b) {
  using ::std::swap;
  swap(a.page_data, b.page_data);
  swap(a.total_pages, b.total_pages);
}

rpc_call_group_scenarios_struct::rpc_call_group_scenarios_struct(const rpc_call_group_scenarios_struct& other29) {
  page_data = other29.page_data;
  total_pages = other29.total_pages;
}
rpc_call_group_scenarios_struct& rpc_call_group_scenarios_struct::operator=(const rpc_call_group_scenarios_struct& other30) {
  page_data = other30.page_data;
  total_pages = other30.total_pages;
  return *this;
}
void rpc_call_group_scenarios_struct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rpc_call_group_scenarios_struct(";
  out << "page_data=" << to_string(page_data);
  out << ", " << "total_pages=" << to_string(total_pages);
  out << ")";
}


rpc_call_doc_group_struct::~rpc_call_doc_group_struct() throw() {
}


void rpc_call_doc_group_struct::__set_page_data(const std::vector<doc_info> & val) {
  this->page_data = val;
}

void rpc_call_doc_group_struct::__set_total_pages(const int32_t val) {
  this->total_pages = val;
}

uint32_t rpc_call_doc_group_struct::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_page_data = false;
  bool isset_total_pages = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->page_data.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->page_data.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += this->page_data[_i35].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_page_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total_pages);
          isset_total_pages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_page_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_total_pages)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t rpc_call_doc_group_struct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("rpc_call_doc_group_struct");

  xfer += oprot->writeFieldBegin("page_data", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->page_data.size()));
    std::vector<doc_info> ::const_iterator _iter36;
    for (_iter36 = this->page_data.begin(); _iter36 != this->page_data.end(); ++_iter36)
    {
      xfer += (*_iter36).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_pages", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->total_pages);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(rpc_call_doc_group_struct &a, rpc_call_doc_group_struct &b) {
  using ::std::swap;
  swap(a.page_data, b.page_data);
  swap(a.total_pages, b.total_pages);
}

rpc_call_doc_group_struct::rpc_call_doc_group_struct(const rpc_call_doc_group_struct& other37) {
  page_data = other37.page_data;
  total_pages = other37.total_pages;
}
rpc_call_doc_group_struct& rpc_call_doc_group_struct::operator=(const rpc_call_doc_group_struct& other38) {
  page_data = other38.page_data;
  total_pages = other38.total_pages;
  return *this;
}
void rpc_call_doc_group_struct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rpc_call_doc_group_struct(";
  out << "page_data=" << to_string(page_data);
  out << ", " << "total_pages=" << to_string(total_pages);
  out << ")";
}


Sentence::~Sentence() throw() {
}


void Sentence::__set_accused(const std::string& val) {
  this->accused = val;
}

void Sentence::__set_penalty(const Penalty::type val) {
  this->penalty = val;
}

void Sentence::__set_duration(const int32_t val) {
  this->duration = val;
}

void Sentence::__set_probation(const double val) {
  this->probation = val;
__isset.probation = true;
}

void Sentence::__set_fine(const double val) {
  this->fine = val;
__isset.fine = true;
}

uint32_t Sentence::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_accused = false;
  bool isset_penalty = false;
  bool isset_duration = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->accused);
          isset_accused = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast39;
          xfer += iprot->readI32(ecast39);
          this->penalty = (Penalty::type)ecast39;
          isset_penalty = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->duration);
          isset_duration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->probation);
          this->__isset.probation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fine);
          this->__isset.fine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_accused)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_penalty)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_duration)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Sentence::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Sentence");

  xfer += oprot->writeFieldBegin("accused", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->accused);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("penalty", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->penalty);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("duration", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->duration);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.probation) {
    xfer += oprot->writeFieldBegin("probation", ::apache::thrift::protocol::T_DOUBLE, 5);
    xfer += oprot->writeDouble(this->probation);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fine) {
    xfer += oprot->writeFieldBegin("fine", ::apache::thrift::protocol::T_DOUBLE, 6);
    xfer += oprot->writeDouble(this->fine);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Sentence &a, Sentence &b) {
  using ::std::swap;
  swap(a.accused, b.accused);
  swap(a.penalty, b.penalty);
  swap(a.duration, b.duration);
  swap(a.probation, b.probation);
  swap(a.fine, b.fine);
  swap(a.__isset, b.__isset);
}

Sentence::Sentence(const Sentence& other40) {
  accused = other40.accused;
  penalty = other40.penalty;
  duration = other40.duration;
  probation = other40.probation;
  fine = other40.fine;
  __isset = other40.__isset;
}
Sentence& Sentence::operator=(const Sentence& other41) {
  accused = other41.accused;
  penalty = other41.penalty;
  duration = other41.duration;
  probation = other41.probation;
  fine = other41.fine;
  __isset = other41.__isset;
  return *this;
}
void Sentence::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Sentence(";
  out << "accused=" << to_string(accused);
  out << ", " << "penalty=" << to_string(penalty);
  out << ", " << "duration=" << to_string(duration);
  out << ", " << "probation="; (__isset.probation ? (out << to_string(probation)) : (out << "<null>"));
  out << ", " << "fine="; (__isset.fine ? (out << to_string(fine)) : (out << "<null>"));
  out << ")";
}


doc_info::~doc_info() throw() {
}


void doc_info::__set_docid(const int32_t val) {
  this->docid = val;
}

void doc_info::__set_sentences(const std::vector<Sentence> & val) {
  this->sentences = val;
}

void doc_info::__set_injury(const int32_t val) {
  this->injury = val;
__isset.injury = true;
}

void doc_info::__set_amount(const double val) {
  this->amount = val;
__isset.amount = true;
}

void doc_info::__set_title(const std::string& val) {
  this->title = val;
__isset.title = true;
}

void doc_info::__set_name(const std::string& val) {
  this->name = val;
}

void doc_info::__set_date(const Timestamp& val) {
  this->date = val;
}

void doc_info::__set_court_name(const std::string& val) {
  this->court_name = val;
}

void doc_info::__set_kind(const int8_t val) {
  this->kind = val;
}

void doc_info::__set_full_text(const std::string& val) {
  this->full_text = val;
}

uint32_t doc_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_docid = false;
  bool isset_sentences = false;
  bool isset_name = false;
  bool isset_date = false;
  bool isset_court_name = false;
  bool isset_kind = false;
  bool isset_full_text = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->docid);
          isset_docid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sentences.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->sentences.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += this->sentences[_i46].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_sentences = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->injury);
          this->__isset.injury = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->amount);
          this->__isset.amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->date);
          isset_date = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->court_name);
          isset_court_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->kind);
          isset_kind = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->full_text);
          isset_full_text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_docid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sentences)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_date)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_court_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_kind)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_full_text)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t doc_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("doc_info");

  xfer += oprot->writeFieldBegin("docid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->docid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sentences", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->sentences.size()));
    std::vector<Sentence> ::const_iterator _iter47;
    for (_iter47 = this->sentences.begin(); _iter47 != this->sentences.end(); ++_iter47)
    {
      xfer += (*_iter47).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.injury) {
    xfer += oprot->writeFieldBegin("injury", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->injury);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.amount) {
    xfer += oprot->writeFieldBegin("amount", ::apache::thrift::protocol::T_DOUBLE, 4);
    xfer += oprot->writeDouble(this->amount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.title) {
    xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->title);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("date", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->date);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("court_name", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->court_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("kind", ::apache::thrift::protocol::T_BYTE, 9);
  xfer += oprot->writeByte(this->kind);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("full_text", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->full_text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(doc_info &a, doc_info &b) {
  using ::std::swap;
  swap(a.docid, b.docid);
  swap(a.sentences, b.sentences);
  swap(a.injury, b.injury);
  swap(a.amount, b.amount);
  swap(a.title, b.title);
  swap(a.name, b.name);
  swap(a.date, b.date);
  swap(a.court_name, b.court_name);
  swap(a.kind, b.kind);
  swap(a.full_text, b.full_text);
  swap(a.__isset, b.__isset);
}

doc_info::doc_info(const doc_info& other48) {
  docid = other48.docid;
  sentences = other48.sentences;
  injury = other48.injury;
  amount = other48.amount;
  title = other48.title;
  name = other48.name;
  date = other48.date;
  court_name = other48.court_name;
  kind = other48.kind;
  full_text = other48.full_text;
  __isset = other48.__isset;
}
doc_info& doc_info::operator=(const doc_info& other49) {
  docid = other49.docid;
  sentences = other49.sentences;
  injury = other49.injury;
  amount = other49.amount;
  title = other49.title;
  name = other49.name;
  date = other49.date;
  court_name = other49.court_name;
  kind = other49.kind;
  full_text = other49.full_text;
  __isset = other49.__isset;
  return *this;
}
void doc_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "doc_info(";
  out << "docid=" << to_string(docid);
  out << ", " << "sentences=" << to_string(sentences);
  out << ", " << "injury="; (__isset.injury ? (out << to_string(injury)) : (out << "<null>"));
  out << ", " << "amount="; (__isset.amount ? (out << to_string(amount)) : (out << "<null>"));
  out << ", " << "title="; (__isset.title ? (out << to_string(title)) : (out << "<null>"));
  out << ", " << "name=" << to_string(name);
  out << ", " << "date=" << to_string(date);
  out << ", " << "court_name=" << to_string(court_name);
  out << ", " << "kind=" << to_string(kind);
  out << ", " << "full_text=" << to_string(full_text);
  out << ")";
}


QueryFailure::~QueryFailure() throw() {
}


void QueryFailure::__set_code(const int8_t val) {
  this->code = val;
}

void QueryFailure::__set_desc(const std::string& val) {
  this->desc = val;
}

uint32_t QueryFailure::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;
  bool isset_desc = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->desc);
          isset_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_desc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t QueryFailure::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("QueryFailure");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("desc", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->desc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QueryFailure &a, QueryFailure &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.desc, b.desc);
}

QueryFailure::QueryFailure(const QueryFailure& other50) : TException() {
  code = other50.code;
  desc = other50.desc;
}
QueryFailure& QueryFailure::operator=(const QueryFailure& other51) {
  code = other51.code;
  desc = other51.desc;
  return *this;
}
void QueryFailure::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "QueryFailure(";
  out << "code=" << to_string(code);
  out << ", " << "desc=" << to_string(desc);
  out << ")";
}

const char* QueryFailure::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: QueryFailure";
  }
}

} // namespace
