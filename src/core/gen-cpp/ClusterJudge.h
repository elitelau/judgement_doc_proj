/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ClusterJudge_H
#define ClusterJudge_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "grouping_shared_types.h"

namespace grouping_shared {

#ifdef _WIN32
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class ClusterJudgeIf {
 public:
  virtual ~ClusterJudgeIf() {}
  virtual void group_scenarios(rpc_call_group_scenarios_struct& _return, const std::string& crime, const int32_t page_no, const int32_t page_size) = 0;
  virtual void get_docs_of_sgroup(rpc_call_doc_group_struct& _return, const std::string& crime, const std::string& data1, const std::string& data2, const int32_t page_no, const int32_t page_size) = 0;
  virtual void get_scenarios_group_sentences(std::vector<Sentence> & _return, const std::string& crime, const int32_t group_id, const int32_t page_no, const int32_t page_size) = 0;
  virtual void get_judge_bases(std::vector<JudgeBases> & _return, const std::vector<int32_t> & docid_array) = 0;
  virtual void group_judge(std::vector<JudgeGroup> & _return, const std::string& crime) = 0;
};

class ClusterJudgeIfFactory {
 public:
  typedef ClusterJudgeIf Handler;

  virtual ~ClusterJudgeIfFactory() {}

  virtual ClusterJudgeIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(ClusterJudgeIf* /* handler */) = 0;
};

class ClusterJudgeIfSingletonFactory : virtual public ClusterJudgeIfFactory {
 public:
  ClusterJudgeIfSingletonFactory(const boost::shared_ptr<ClusterJudgeIf>& iface) : iface_(iface) {}
  virtual ~ClusterJudgeIfSingletonFactory() {}

  virtual ClusterJudgeIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(ClusterJudgeIf* /* handler */) {}

 protected:
  boost::shared_ptr<ClusterJudgeIf> iface_;
};

class ClusterJudgeNull : virtual public ClusterJudgeIf {
 public:
  virtual ~ClusterJudgeNull() {}
  void group_scenarios(rpc_call_group_scenarios_struct& /* _return */, const std::string& /* crime */, const int32_t /* page_no */, const int32_t /* page_size */) {
    return;
  }
  void get_docs_of_sgroup(rpc_call_doc_group_struct& /* _return */, const std::string& /* crime */, const std::string& /* data1 */, const std::string& /* data2 */, const int32_t /* page_no */, const int32_t /* page_size */) {
    return;
  }
  void get_scenarios_group_sentences(std::vector<Sentence> & /* _return */, const std::string& /* crime */, const int32_t /* group_id */, const int32_t /* page_no */, const int32_t /* page_size */) {
    return;
  }
  void get_judge_bases(std::vector<JudgeBases> & /* _return */, const std::vector<int32_t> & /* docid_array */) {
    return;
  }
  void group_judge(std::vector<JudgeGroup> & /* _return */, const std::string& /* crime */) {
    return;
  }
};

typedef struct _ClusterJudge_group_scenarios_args__isset {
  _ClusterJudge_group_scenarios_args__isset() : crime(false), page_no(false), page_size(false) {}
  bool crime :1;
  bool page_no :1;
  bool page_size :1;
} _ClusterJudge_group_scenarios_args__isset;

class ClusterJudge_group_scenarios_args {
 public:

  ClusterJudge_group_scenarios_args(const ClusterJudge_group_scenarios_args&);
  ClusterJudge_group_scenarios_args& operator=(const ClusterJudge_group_scenarios_args&);
  ClusterJudge_group_scenarios_args() : crime(), page_no(0), page_size(0) {
  }

  virtual ~ClusterJudge_group_scenarios_args() throw();
  std::string crime;
  int32_t page_no;
  int32_t page_size;

  _ClusterJudge_group_scenarios_args__isset __isset;

  void __set_crime(const std::string& val);

  void __set_page_no(const int32_t val);

  void __set_page_size(const int32_t val);

  bool operator == (const ClusterJudge_group_scenarios_args & rhs) const
  {
    if (!(crime == rhs.crime))
      return false;
    if (!(page_no == rhs.page_no))
      return false;
    if (!(page_size == rhs.page_size))
      return false;
    return true;
  }
  bool operator != (const ClusterJudge_group_scenarios_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterJudge_group_scenarios_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClusterJudge_group_scenarios_pargs {
 public:


  virtual ~ClusterJudge_group_scenarios_pargs() throw();
  const std::string* crime;
  const int32_t* page_no;
  const int32_t* page_size;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClusterJudge_group_scenarios_result__isset {
  _ClusterJudge_group_scenarios_result__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _ClusterJudge_group_scenarios_result__isset;

class ClusterJudge_group_scenarios_result {
 public:

  ClusterJudge_group_scenarios_result(const ClusterJudge_group_scenarios_result&);
  ClusterJudge_group_scenarios_result& operator=(const ClusterJudge_group_scenarios_result&);
  ClusterJudge_group_scenarios_result() {
  }

  virtual ~ClusterJudge_group_scenarios_result() throw();
  rpc_call_group_scenarios_struct success;
  QueryFailure ouch;

  _ClusterJudge_group_scenarios_result__isset __isset;

  void __set_success(const rpc_call_group_scenarios_struct& val);

  void __set_ouch(const QueryFailure& val);

  bool operator == (const ClusterJudge_group_scenarios_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch == rhs.ouch))
      return false;
    return true;
  }
  bool operator != (const ClusterJudge_group_scenarios_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterJudge_group_scenarios_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClusterJudge_group_scenarios_presult__isset {
  _ClusterJudge_group_scenarios_presult__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _ClusterJudge_group_scenarios_presult__isset;

class ClusterJudge_group_scenarios_presult {
 public:


  virtual ~ClusterJudge_group_scenarios_presult() throw();
  rpc_call_group_scenarios_struct* success;
  QueryFailure ouch;

  _ClusterJudge_group_scenarios_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClusterJudge_get_docs_of_sgroup_args__isset {
  _ClusterJudge_get_docs_of_sgroup_args__isset() : crime(false), data1(false), data2(false), page_no(false), page_size(false) {}
  bool crime :1;
  bool data1 :1;
  bool data2 :1;
  bool page_no :1;
  bool page_size :1;
} _ClusterJudge_get_docs_of_sgroup_args__isset;

class ClusterJudge_get_docs_of_sgroup_args {
 public:

  ClusterJudge_get_docs_of_sgroup_args(const ClusterJudge_get_docs_of_sgroup_args&);
  ClusterJudge_get_docs_of_sgroup_args& operator=(const ClusterJudge_get_docs_of_sgroup_args&);
  ClusterJudge_get_docs_of_sgroup_args() : crime(), data1(), data2(), page_no(0), page_size(0) {
  }

  virtual ~ClusterJudge_get_docs_of_sgroup_args() throw();
  std::string crime;
  std::string data1;
  std::string data2;
  int32_t page_no;
  int32_t page_size;

  _ClusterJudge_get_docs_of_sgroup_args__isset __isset;

  void __set_crime(const std::string& val);

  void __set_data1(const std::string& val);

  void __set_data2(const std::string& val);

  void __set_page_no(const int32_t val);

  void __set_page_size(const int32_t val);

  bool operator == (const ClusterJudge_get_docs_of_sgroup_args & rhs) const
  {
    if (!(crime == rhs.crime))
      return false;
    if (!(data1 == rhs.data1))
      return false;
    if (!(data2 == rhs.data2))
      return false;
    if (!(page_no == rhs.page_no))
      return false;
    if (!(page_size == rhs.page_size))
      return false;
    return true;
  }
  bool operator != (const ClusterJudge_get_docs_of_sgroup_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterJudge_get_docs_of_sgroup_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClusterJudge_get_docs_of_sgroup_pargs {
 public:


  virtual ~ClusterJudge_get_docs_of_sgroup_pargs() throw();
  const std::string* crime;
  const std::string* data1;
  const std::string* data2;
  const int32_t* page_no;
  const int32_t* page_size;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClusterJudge_get_docs_of_sgroup_result__isset {
  _ClusterJudge_get_docs_of_sgroup_result__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _ClusterJudge_get_docs_of_sgroup_result__isset;

class ClusterJudge_get_docs_of_sgroup_result {
 public:

  ClusterJudge_get_docs_of_sgroup_result(const ClusterJudge_get_docs_of_sgroup_result&);
  ClusterJudge_get_docs_of_sgroup_result& operator=(const ClusterJudge_get_docs_of_sgroup_result&);
  ClusterJudge_get_docs_of_sgroup_result() {
  }

  virtual ~ClusterJudge_get_docs_of_sgroup_result() throw();
  rpc_call_doc_group_struct success;
  QueryFailure ouch;

  _ClusterJudge_get_docs_of_sgroup_result__isset __isset;

  void __set_success(const rpc_call_doc_group_struct& val);

  void __set_ouch(const QueryFailure& val);

  bool operator == (const ClusterJudge_get_docs_of_sgroup_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch == rhs.ouch))
      return false;
    return true;
  }
  bool operator != (const ClusterJudge_get_docs_of_sgroup_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterJudge_get_docs_of_sgroup_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClusterJudge_get_docs_of_sgroup_presult__isset {
  _ClusterJudge_get_docs_of_sgroup_presult__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _ClusterJudge_get_docs_of_sgroup_presult__isset;

class ClusterJudge_get_docs_of_sgroup_presult {
 public:


  virtual ~ClusterJudge_get_docs_of_sgroup_presult() throw();
  rpc_call_doc_group_struct* success;
  QueryFailure ouch;

  _ClusterJudge_get_docs_of_sgroup_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClusterJudge_get_scenarios_group_sentences_args__isset {
  _ClusterJudge_get_scenarios_group_sentences_args__isset() : crime(false), group_id(false), page_no(false), page_size(false) {}
  bool crime :1;
  bool group_id :1;
  bool page_no :1;
  bool page_size :1;
} _ClusterJudge_get_scenarios_group_sentences_args__isset;

class ClusterJudge_get_scenarios_group_sentences_args {
 public:

  ClusterJudge_get_scenarios_group_sentences_args(const ClusterJudge_get_scenarios_group_sentences_args&);
  ClusterJudge_get_scenarios_group_sentences_args& operator=(const ClusterJudge_get_scenarios_group_sentences_args&);
  ClusterJudge_get_scenarios_group_sentences_args() : crime(), group_id(0), page_no(0), page_size(0) {
  }

  virtual ~ClusterJudge_get_scenarios_group_sentences_args() throw();
  std::string crime;
  int32_t group_id;
  int32_t page_no;
  int32_t page_size;

  _ClusterJudge_get_scenarios_group_sentences_args__isset __isset;

  void __set_crime(const std::string& val);

  void __set_group_id(const int32_t val);

  void __set_page_no(const int32_t val);

  void __set_page_size(const int32_t val);

  bool operator == (const ClusterJudge_get_scenarios_group_sentences_args & rhs) const
  {
    if (!(crime == rhs.crime))
      return false;
    if (!(group_id == rhs.group_id))
      return false;
    if (!(page_no == rhs.page_no))
      return false;
    if (!(page_size == rhs.page_size))
      return false;
    return true;
  }
  bool operator != (const ClusterJudge_get_scenarios_group_sentences_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterJudge_get_scenarios_group_sentences_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClusterJudge_get_scenarios_group_sentences_pargs {
 public:


  virtual ~ClusterJudge_get_scenarios_group_sentences_pargs() throw();
  const std::string* crime;
  const int32_t* group_id;
  const int32_t* page_no;
  const int32_t* page_size;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClusterJudge_get_scenarios_group_sentences_result__isset {
  _ClusterJudge_get_scenarios_group_sentences_result__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _ClusterJudge_get_scenarios_group_sentences_result__isset;

class ClusterJudge_get_scenarios_group_sentences_result {
 public:

  ClusterJudge_get_scenarios_group_sentences_result(const ClusterJudge_get_scenarios_group_sentences_result&);
  ClusterJudge_get_scenarios_group_sentences_result& operator=(const ClusterJudge_get_scenarios_group_sentences_result&);
  ClusterJudge_get_scenarios_group_sentences_result() {
  }

  virtual ~ClusterJudge_get_scenarios_group_sentences_result() throw();
  std::vector<Sentence>  success;
  QueryFailure ouch;

  _ClusterJudge_get_scenarios_group_sentences_result__isset __isset;

  void __set_success(const std::vector<Sentence> & val);

  void __set_ouch(const QueryFailure& val);

  bool operator == (const ClusterJudge_get_scenarios_group_sentences_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch == rhs.ouch))
      return false;
    return true;
  }
  bool operator != (const ClusterJudge_get_scenarios_group_sentences_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterJudge_get_scenarios_group_sentences_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClusterJudge_get_scenarios_group_sentences_presult__isset {
  _ClusterJudge_get_scenarios_group_sentences_presult__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _ClusterJudge_get_scenarios_group_sentences_presult__isset;

class ClusterJudge_get_scenarios_group_sentences_presult {
 public:


  virtual ~ClusterJudge_get_scenarios_group_sentences_presult() throw();
  std::vector<Sentence> * success;
  QueryFailure ouch;

  _ClusterJudge_get_scenarios_group_sentences_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClusterJudge_get_judge_bases_args__isset {
  _ClusterJudge_get_judge_bases_args__isset() : docid_array(false) {}
  bool docid_array :1;
} _ClusterJudge_get_judge_bases_args__isset;

class ClusterJudge_get_judge_bases_args {
 public:

  ClusterJudge_get_judge_bases_args(const ClusterJudge_get_judge_bases_args&);
  ClusterJudge_get_judge_bases_args& operator=(const ClusterJudge_get_judge_bases_args&);
  ClusterJudge_get_judge_bases_args() {
  }

  virtual ~ClusterJudge_get_judge_bases_args() throw();
  std::vector<int32_t>  docid_array;

  _ClusterJudge_get_judge_bases_args__isset __isset;

  void __set_docid_array(const std::vector<int32_t> & val);

  bool operator == (const ClusterJudge_get_judge_bases_args & rhs) const
  {
    if (!(docid_array == rhs.docid_array))
      return false;
    return true;
  }
  bool operator != (const ClusterJudge_get_judge_bases_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterJudge_get_judge_bases_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClusterJudge_get_judge_bases_pargs {
 public:


  virtual ~ClusterJudge_get_judge_bases_pargs() throw();
  const std::vector<int32_t> * docid_array;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClusterJudge_get_judge_bases_result__isset {
  _ClusterJudge_get_judge_bases_result__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _ClusterJudge_get_judge_bases_result__isset;

class ClusterJudge_get_judge_bases_result {
 public:

  ClusterJudge_get_judge_bases_result(const ClusterJudge_get_judge_bases_result&);
  ClusterJudge_get_judge_bases_result& operator=(const ClusterJudge_get_judge_bases_result&);
  ClusterJudge_get_judge_bases_result() {
  }

  virtual ~ClusterJudge_get_judge_bases_result() throw();
  std::vector<JudgeBases>  success;
  QueryFailure ouch;

  _ClusterJudge_get_judge_bases_result__isset __isset;

  void __set_success(const std::vector<JudgeBases> & val);

  void __set_ouch(const QueryFailure& val);

  bool operator == (const ClusterJudge_get_judge_bases_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch == rhs.ouch))
      return false;
    return true;
  }
  bool operator != (const ClusterJudge_get_judge_bases_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterJudge_get_judge_bases_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClusterJudge_get_judge_bases_presult__isset {
  _ClusterJudge_get_judge_bases_presult__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _ClusterJudge_get_judge_bases_presult__isset;

class ClusterJudge_get_judge_bases_presult {
 public:


  virtual ~ClusterJudge_get_judge_bases_presult() throw();
  std::vector<JudgeBases> * success;
  QueryFailure ouch;

  _ClusterJudge_get_judge_bases_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClusterJudge_group_judge_args__isset {
  _ClusterJudge_group_judge_args__isset() : crime(false) {}
  bool crime :1;
} _ClusterJudge_group_judge_args__isset;

class ClusterJudge_group_judge_args {
 public:

  ClusterJudge_group_judge_args(const ClusterJudge_group_judge_args&);
  ClusterJudge_group_judge_args& operator=(const ClusterJudge_group_judge_args&);
  ClusterJudge_group_judge_args() : crime() {
  }

  virtual ~ClusterJudge_group_judge_args() throw();
  std::string crime;

  _ClusterJudge_group_judge_args__isset __isset;

  void __set_crime(const std::string& val);

  bool operator == (const ClusterJudge_group_judge_args & rhs) const
  {
    if (!(crime == rhs.crime))
      return false;
    return true;
  }
  bool operator != (const ClusterJudge_group_judge_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterJudge_group_judge_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClusterJudge_group_judge_pargs {
 public:


  virtual ~ClusterJudge_group_judge_pargs() throw();
  const std::string* crime;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClusterJudge_group_judge_result__isset {
  _ClusterJudge_group_judge_result__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _ClusterJudge_group_judge_result__isset;

class ClusterJudge_group_judge_result {
 public:

  ClusterJudge_group_judge_result(const ClusterJudge_group_judge_result&);
  ClusterJudge_group_judge_result& operator=(const ClusterJudge_group_judge_result&);
  ClusterJudge_group_judge_result() {
  }

  virtual ~ClusterJudge_group_judge_result() throw();
  std::vector<JudgeGroup>  success;
  QueryFailure ouch;

  _ClusterJudge_group_judge_result__isset __isset;

  void __set_success(const std::vector<JudgeGroup> & val);

  void __set_ouch(const QueryFailure& val);

  bool operator == (const ClusterJudge_group_judge_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch == rhs.ouch))
      return false;
    return true;
  }
  bool operator != (const ClusterJudge_group_judge_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterJudge_group_judge_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClusterJudge_group_judge_presult__isset {
  _ClusterJudge_group_judge_presult__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _ClusterJudge_group_judge_presult__isset;

class ClusterJudge_group_judge_presult {
 public:


  virtual ~ClusterJudge_group_judge_presult() throw();
  std::vector<JudgeGroup> * success;
  QueryFailure ouch;

  _ClusterJudge_group_judge_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class ClusterJudgeClient : virtual public ClusterJudgeIf {
 public:
  ClusterJudgeClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  ClusterJudgeClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void group_scenarios(rpc_call_group_scenarios_struct& _return, const std::string& crime, const int32_t page_no, const int32_t page_size);
  void send_group_scenarios(const std::string& crime, const int32_t page_no, const int32_t page_size);
  void recv_group_scenarios(rpc_call_group_scenarios_struct& _return);
  void get_docs_of_sgroup(rpc_call_doc_group_struct& _return, const std::string& crime, const std::string& data1, const std::string& data2, const int32_t page_no, const int32_t page_size);
  void send_get_docs_of_sgroup(const std::string& crime, const std::string& data1, const std::string& data2, const int32_t page_no, const int32_t page_size);
  void recv_get_docs_of_sgroup(rpc_call_doc_group_struct& _return);
  void get_scenarios_group_sentences(std::vector<Sentence> & _return, const std::string& crime, const int32_t group_id, const int32_t page_no, const int32_t page_size);
  void send_get_scenarios_group_sentences(const std::string& crime, const int32_t group_id, const int32_t page_no, const int32_t page_size);
  void recv_get_scenarios_group_sentences(std::vector<Sentence> & _return);
  void get_judge_bases(std::vector<JudgeBases> & _return, const std::vector<int32_t> & docid_array);
  void send_get_judge_bases(const std::vector<int32_t> & docid_array);
  void recv_get_judge_bases(std::vector<JudgeBases> & _return);
  void group_judge(std::vector<JudgeGroup> & _return, const std::string& crime);
  void send_group_judge(const std::string& crime);
  void recv_group_judge(std::vector<JudgeGroup> & _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class ClusterJudgeProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<ClusterJudgeIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (ClusterJudgeProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_group_scenarios(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_docs_of_sgroup(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_scenarios_group_sentences(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_judge_bases(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_group_judge(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  ClusterJudgeProcessor(boost::shared_ptr<ClusterJudgeIf> iface) :
    iface_(iface) {
    processMap_["group_scenarios"] = &ClusterJudgeProcessor::process_group_scenarios;
    processMap_["get_docs_of_sgroup"] = &ClusterJudgeProcessor::process_get_docs_of_sgroup;
    processMap_["get_scenarios_group_sentences"] = &ClusterJudgeProcessor::process_get_scenarios_group_sentences;
    processMap_["get_judge_bases"] = &ClusterJudgeProcessor::process_get_judge_bases;
    processMap_["group_judge"] = &ClusterJudgeProcessor::process_group_judge;
  }

  virtual ~ClusterJudgeProcessor() {}
};

class ClusterJudgeProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  ClusterJudgeProcessorFactory(const ::boost::shared_ptr< ClusterJudgeIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< ClusterJudgeIfFactory > handlerFactory_;
};

class ClusterJudgeMultiface : virtual public ClusterJudgeIf {
 public:
  ClusterJudgeMultiface(std::vector<boost::shared_ptr<ClusterJudgeIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~ClusterJudgeMultiface() {}
 protected:
  std::vector<boost::shared_ptr<ClusterJudgeIf> > ifaces_;
  ClusterJudgeMultiface() {}
  void add(boost::shared_ptr<ClusterJudgeIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void group_scenarios(rpc_call_group_scenarios_struct& _return, const std::string& crime, const int32_t page_no, const int32_t page_size) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->group_scenarios(_return, crime, page_no, page_size);
    }
    ifaces_[i]->group_scenarios(_return, crime, page_no, page_size);
    return;
  }

  void get_docs_of_sgroup(rpc_call_doc_group_struct& _return, const std::string& crime, const std::string& data1, const std::string& data2, const int32_t page_no, const int32_t page_size) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_docs_of_sgroup(_return, crime, data1, data2, page_no, page_size);
    }
    ifaces_[i]->get_docs_of_sgroup(_return, crime, data1, data2, page_no, page_size);
    return;
  }

  void get_scenarios_group_sentences(std::vector<Sentence> & _return, const std::string& crime, const int32_t group_id, const int32_t page_no, const int32_t page_size) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_scenarios_group_sentences(_return, crime, group_id, page_no, page_size);
    }
    ifaces_[i]->get_scenarios_group_sentences(_return, crime, group_id, page_no, page_size);
    return;
  }

  void get_judge_bases(std::vector<JudgeBases> & _return, const std::vector<int32_t> & docid_array) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_judge_bases(_return, docid_array);
    }
    ifaces_[i]->get_judge_bases(_return, docid_array);
    return;
  }

  void group_judge(std::vector<JudgeGroup> & _return, const std::string& crime) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->group_judge(_return, crime);
    }
    ifaces_[i]->group_judge(_return, crime);
    return;
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class ClusterJudgeConcurrentClient : virtual public ClusterJudgeIf {
 public:
  ClusterJudgeConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  ClusterJudgeConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void group_scenarios(rpc_call_group_scenarios_struct& _return, const std::string& crime, const int32_t page_no, const int32_t page_size);
  int32_t send_group_scenarios(const std::string& crime, const int32_t page_no, const int32_t page_size);
  void recv_group_scenarios(rpc_call_group_scenarios_struct& _return, const int32_t seqid);
  void get_docs_of_sgroup(rpc_call_doc_group_struct& _return, const std::string& crime, const std::string& data1, const std::string& data2, const int32_t page_no, const int32_t page_size);
  int32_t send_get_docs_of_sgroup(const std::string& crime, const std::string& data1, const std::string& data2, const int32_t page_no, const int32_t page_size);
  void recv_get_docs_of_sgroup(rpc_call_doc_group_struct& _return, const int32_t seqid);
  void get_scenarios_group_sentences(std::vector<Sentence> & _return, const std::string& crime, const int32_t group_id, const int32_t page_no, const int32_t page_size);
  int32_t send_get_scenarios_group_sentences(const std::string& crime, const int32_t group_id, const int32_t page_no, const int32_t page_size);
  void recv_get_scenarios_group_sentences(std::vector<Sentence> & _return, const int32_t seqid);
  void get_judge_bases(std::vector<JudgeBases> & _return, const std::vector<int32_t> & docid_array);
  int32_t send_get_judge_bases(const std::vector<int32_t> & docid_array);
  void recv_get_judge_bases(std::vector<JudgeBases> & _return, const int32_t seqid);
  void group_judge(std::vector<JudgeGroup> & _return, const std::string& crime);
  int32_t send_group_judge(const std::string& crime);
  void recv_group_judge(std::vector<JudgeGroup> & _return, const int32_t seqid);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _WIN32
  #pragma warning( pop )
#endif

} // namespace

#endif
